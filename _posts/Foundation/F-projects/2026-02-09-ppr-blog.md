---
layout: post
title: Personal Project Reference- Citation Generator
permalink: /ppr
comments: true
---

# Personal Project Reference (PPR)
## AP Computer Science Principles - Media Literacy Citation Generator

---

## Project Overview

This citation generator helps students create properly formatted academic citations in APA, MLA, and Chicago styles while managing a collection of saved references. The program demonstrates data abstraction through list processing and includes algorithms for filtering, sorting, and quality-checking citations.

---

## COMPONENT A: PROGRAM CODE

### Code Segment 1: Student-Developed Procedure with Algorithm

**Purpose:** This procedure processes and filters a collection of citations based on style and maximum items, demonstrating sequencing, selection, and iteration.

**Key Features:**
- **Parameters:** Takes `citationList` (array), `filterStyle` (string), and `maxItems` (number)
- **Return type:** Returns an object containing filtered citations and statistics  
- **Algorithm elements:** Includes sequencing (ordered steps), selection (conditional logic), and iteration (loops)
- **Data abstraction:** Works with a list/collection of citation objects
- **Manages complexity:** Encapsulates complex filtering logic in a reusable function

```javascript
function processCitationList(citationList, filterStyle, maxItems) {
    let filtered = [];
    let styleCount = { apa: 0, mla: 0, chicago: 0 };
    
    for (let i = 0; i < citationList.length; i++) {
        let citation = citationList[i];
        
        if (filterStyle === 'all' || citation.style === filterStyle) {
            filtered.push(citation);
        }
        
        if (citation.style && styleCount.hasOwnProperty(citation.style)) {
            styleCount[citation.style]++;
        }
        
        if (filtered.length >= maxItems) {
            break;
        }
    }
    
    return {
        citations: filtered,
        totalCount: citationList.length,
        styleCounts: styleCount
    };
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
/* 
 * STUDENT-DEVELOPED PROCEDURE: processCitationList
 * Purpose: Process and filter a list of saved citations based on style and date range
 * Parameters:
 *   - citationList (array): List of citation objects to process
 *   - filterStyle (string): Citation style to filter by (e.g., "apa", "mla", "chicago", or "all")
 *   - maxItems (number): Maximum number of items to return
 * Return type: Object containing filtered citations and statistics
 * 
 * This procedure demonstrates:
 * - LISTS/COLLECTION: Works with array of citation objects
 * - ITERATION: Loops through citation list
 * - SEQUENCING: Steps execute in specific order
 * - SELECTION: Conditional logic for filtering
 * - ALGORITHM: Complete process for filtering and counting
 * - ABSTRACTION: Encapsulates complex filtering logic
 */

function processCitationList(citationList, filterStyle, maxItems) {
    // SEQUENCING: Initialize variables in order
    let filtered = [];  // Array to store filtered results
    let styleCount = { apa: 0, mla: 0, chicago: 0 };  // Object to track count by style
    
    // ITERATION: Loop through each citation in the list
    for (let i = 0; i < citationList.length; i++) {
        let citation = citationList[i];  // Get current citation object
        
        // SELECTION: Conditional logic to filter by style
        // If filterStyle is 'all', include everything
        // Otherwise, only include citations matching the specified style
        if (filterStyle === 'all' || citation.style === filterStyle) {
            filtered.push(citation);  // Add to filtered array
        }
        
        // Count citations by style for statistics
        // hasOwnProperty checks if the style exists in our styleCount object
        if (citation.style && styleCount.hasOwnProperty(citation.style)) {
            styleCount[citation.style]++;  // Increment count for this style
        }
        
        // SELECTION: Stop if we've reached max items
        // This optimizes performance by not processing unnecessary items
        if (filtered.length >= maxItems) {
            break;  // Exit the loop early
        }
    }
    
    // Return processed data as an object
    // This demonstrates data abstraction - bundling related data together
    return {
        citations: filtered,              // The filtered list of citations
        totalCount: citationList.length,  // Total number of citations (before filtering)
        styleCounts: styleCount           // Statistics about citation styles
    };
}
</code></pre>

</details>

---

### Code Segment 2: List Data Structure - Storing Citations

**Purpose:** This code demonstrates how citation data is stored in a list (array) structure using localStorage, showing data abstraction at work.

**Key Features:**
- **Input collection:** Gathers user form data into a payload object
- **List manipulation:** Retrieves existing array from storage, adds new item, saves back
- **Data abstraction:** The list manages multiple citation objects, each with multiple properties
- **Managing complexity:** The collection allows the program to handle many citations efficiently

```javascript
function saveToWorksCited() {
    const citation = generate();
    if (!citation || citation.length < 5) {
        alert('Please generate a citation first.');
        return;
    }
    
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };
    
    const style = styleEl.value;
    const parenthetical = buildParenthetical({ ...payload, style });
    
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    const newCitation = { 
        citation, 
        style: styleEl.value,
        at: Date.now(),
        source: safe(sourceEl.value),
        title: safe(titleEl.value),
        url: safe(urlEl.value),
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        parenthetical: parenthetical
    };
    
    saved.push(newCitation);
    
    localStorage.setItem(KEY, JSON.stringify(saved));
    alert('‚úì Citation saved to References!');
    
    loadWorksCited();
    updateNotesSourceSelect();
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
// LIST: Save citation to collection
function saveToWorksCited() {
    // First, generate the formatted citation
    const citation = generate();
    
    // VALIDATION: Check if citation was successfully generated
    // A valid citation should have more than 5 characters
    if (!citation || citation.length < 5) {
        alert('Please generate a citation first.');
        return;  // Exit early if no valid citation
    }
    
    // INPUT COLLECTION: Gather all form field values into a payload object
    // safe() function trims whitespace and handles null/undefined values
    const payload = {
        author: safe(authorEl.value),    // Author's name
        date: safe(dateEl.value),        // Publication date
        title: safe(titleEl.value),      // Article/book title
        source: safe(sourceEl.value),    // Publication source/website
        url: safe(urlEl.value)           // Web URL
    };
    
    // Get the selected citation style (APA, MLA, or Chicago)
    const style = styleEl.value;
    
    // Build parenthetical citation (e.g., "(Author, 2024)" for APA)
    // The spread operator {...payload, style} combines payload with style
    const parenthetical = buildParenthetical({ ...payload, style });
    
    // LIST RETRIEVAL: Get existing citations array from localStorage
    // JSON.parse converts the stored string back into a JavaScript array
    // The || '[]' provides a default empty array if nothing is stored yet
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    // LIST ITEM: Create new citation object with all necessary data
    // This object will be added to our citations array
    const newCitation = { 
        citation,                          // The formatted citation text
        style: styleEl.value,              // Citation style (apa/mla/chicago)
        at: Date.now(),                    // Timestamp when saved
        source: safe(sourceEl.value),      // Source name for reference
        title: safe(titleEl.value),        // Title for reference
        url: safe(urlEl.value),            // URL for reference
        author: safe(authorEl.value),      // Author for reference
        date: safe(dateEl.value),          // Date for reference
        parenthetical: parenthetical       // Parenthetical citation for in-text use
    };
    
    // LIST MANIPULATION: Add new citation to the end of the array
    // push() is an array method that adds an element to the end
    saved.push(newCitation);
    
    // LIST STORAGE: Save updated array back to localStorage
    // JSON.stringify converts the array to a string for storage
    localStorage.setItem(KEY, JSON.stringify(saved));
    
    // OUTPUT: Confirm to user that citation was saved
    alert('‚úì Citation saved to References!');
    
    // Update the display to show the new citation
    loadWorksCited();
    
    // Update dropdown menu for source notes feature
    updateNotesSourceSelect();
}
</code></pre>

</details>

---

### Code Segment 3: Using List Data - Processing and Display

**Purpose:** This code retrieves the citation list and processes it to display organized references by style, demonstrating how the list abstraction manages program complexity.

**Key Features:**
- **List retrieval:** Gets the stored array from localStorage
- **Data organization:** Groups citations by style (APA, MLA, Chicago) using nested loops
- **Iteration:** Processes each citation in the list with `forEach` loops
- **Managing complexity:** The list structure allows organized display of many citations without tracking individual variables

```javascript
async function loadWorksCited() {
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    if (saved.length === 0) {
        worksCitedSection.style.display = 'none';
        return;
    }

    worksCitedSection.style.display = 'block';
    worksCitedByStyle.innerHTML = '';

    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    saved.forEach((item, index) => {
        if (byStyle[item.style]) {
            byStyle[item.style].push({ item, index });
        }
    });

    const styleLabels = {
        apa: 'APA',
        mla: 'MLA (9th ed.)',
        chicago: 'Chicago (author-date)'
    };

    ['apa', 'mla', 'chicago'].forEach(style => {
        if (byStyle[style].length > 0) {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'style-group';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'style-group-header';
            headerDiv.textContent = `${styleLabels[style]} (${byStyle[style].length})`;
            groupDiv.appendChild(headerDiv);

            const listDiv = document.createElement('div');
            listDiv.className = 'works-cited-list';

            byStyle[style].forEach(async ({ item, index }) => {
                const citationDiv = document.createElement('div');
                citationDiv.className = 'citation-item';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'citation-text';
                textDiv.innerHTML = item.citation;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'citation-actions';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'citation-delete';
                deleteBtn.innerHTML = '√ó';
                deleteBtn.title = 'Delete this citation';
                deleteBtn.onclick = () => deleteCitation(index);
                
                actionsDiv.appendChild(deleteBtn);
                citationDiv.appendChild(textDiv);
                citationDiv.appendChild(actionsDiv);
                listDiv.appendChild(citationDiv);
            });

            groupDiv.appendChild(listDiv);
            worksCitedByStyle.appendChild(groupDiv);
        }
    });
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
// OUTPUT: Display filtered and processed citations organized by style
async function loadWorksCited() {
    // LIST RETRIEVAL: Get the list of saved citations from localStorage
    // JSON.parse converts the JSON string back into a JavaScript array
    // The || '[]' provides an empty array if nothing is stored
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    // SELECTION: Check if list is empty
    if (saved.length === 0) {
        // Hide the works cited section if no citations exist
        worksCitedSection.style.display = 'none';
        return;  // Exit function early
    }

    // Show the works cited section and clear previous content
    worksCitedSection.style.display = 'block';
    worksCitedByStyle.innerHTML = '';  // Clear any existing HTML

    // DATA ORGANIZATION: Create object to group citations by style
    // This demonstrates data abstraction - organizing complex data into categories
    const byStyle = {
        apa: [],       // Array for APA citations
        mla: [],       // Array for MLA citations
        chicago: []    // Array for Chicago citations
    };

    // ITERATION: Process each citation in the saved list
    // forEach is an array method that executes a function for each element
    // item = current citation object, index = position in array
    saved.forEach((item, index) => {
        // SELECTION: Check if this citation style exists in our categories
        if (byStyle[item.style]) {
            // Add this citation to the appropriate style array
            // We store both the item and its index for later use
            byStyle[item.style].push({ item, index });
        }
    });

    // Create human-readable labels for each citation style
    const styleLabels = {
        apa: 'APA',
        mla: 'MLA (9th ed.)',
        chicago: 'Chicago (author-date)'
    };

    // ITERATION: Loop through each citation style to create display sections
    // This is an array of strings ['apa', 'mla', 'chicago']
    ['apa', 'mla', 'chicago'].forEach(style => {
        // SELECTION: Only create a section if there are citations in this style
        if (byStyle[style].length > 0) {
            // DOM MANIPULATION: Create container for this style group
            const groupDiv = document.createElement('div');
            groupDiv.className = 'style-group';
            
            // Create header showing style name and count
            const headerDiv = document.createElement('div');
            headerDiv.className = 'style-group-header';
            // Template literal ${} inserts variables into string
            headerDiv.textContent = `${styleLabels[style]} (${byStyle[style].length})`;
            groupDiv.appendChild(headerDiv);  // Add header to group

            // Create container for the list of citations
            const listDiv = document.createElement('div');
            listDiv.className = 'works-cited-list';

            // ITERATION: Create display element for each citation in this style
            // Async allows us to await quality checks later
            // Destructuring {item, index} extracts properties from object
            byStyle[style].forEach(async ({ item, index }) => {
                // Create container for individual citation
                const citationDiv = document.createElement('div');
                citationDiv.className = 'citation-item';
                
                // Create div for citation text
                const textDiv = document.createElement('div');
                textDiv.className = 'citation-text';
                textDiv.innerHTML = item.citation;  // Set the formatted citation
                
                // Create container for action buttons
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'citation-actions';
                
                // Create delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'citation-delete';
                deleteBtn.innerHTML = '√ó';  // √ó symbol
                deleteBtn.title = 'Delete this citation';
                // Event handler - calls deleteCitation with this item's index
                deleteBtn.onclick = () => deleteCitation(index);
                
                // Assemble all the pieces together
                actionsDiv.appendChild(deleteBtn);       // Add button to actions
                citationDiv.appendChild(textDiv);         // Add text to citation
                citationDiv.appendChild(actionsDiv);      // Add actions to citation
                listDiv.appendChild(citationDiv);         // Add citation to list
            });

            // Add the complete list to the group
            groupDiv.appendChild(listDiv);
            // Add the complete group to the main display area
            worksCitedByStyle.appendChild(groupDiv);
        }
    });
}
</code></pre>

</details>

---

### Code Segment 4: Input Processing - User Form Data

**Purpose:** This code demonstrates input collection from user interface elements (form fields).

**Key Features:**
- **Input collection:** Gathers data from multiple HTML form fields
- **Validation:** Checks for missing required fields and highlights them
- **Selection:** Uses conditional logic to choose formatting function based on citation style
- **Visual output:** Displays formatted citation and shows warnings for missing information

```javascript
function generate() {
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };

    const missing = [];
    const fields = [
        { el: authorEl, key: 'author', label: 'Author' },
        { el: titleEl, key: 'title', label: 'Title' },
        { el: sourceEl, key: 'source', label: 'Source / Website' },
        { el: dateEl, key: 'date', label: 'Publication Date' }
    ];

    fields.forEach(f => f.el.classList.remove('missing'));

    fields.forEach(f => {
        if (!payload[f.key]) {
            missing.push(f.label);
            f.el.classList.add('missing');
        }
    });

    const style = styleEl.value;
    let citation = '';
    if (style === 'mla') citation = fmtMLA9(payload);
    else if (style === 'chicago') citation = fmtChicago(payload);
    else citation = fmtAPA(payload);

    outTextEl.innerHTML = citation;

    const parentheticalEl = document.getElementById('cite-parenthetical');
    const parenthetical = buildParenthetical({ ...payload, style });

    if (parentheticalEl) {
        parentheticalEl.innerHTML = parenthetical
            ? `<span class="citation-output-label">Parenthetical Citation:</span>${parenthetical}`
            : '';
    }

    const warningEl = document.getElementById('cite-warning');
    if (missing.length > 0) {
        warningEl.innerHTML =
            `‚ö†Ô∏è Missing citation info: <b>${missing.join(', ')}</b><br>
             Please manually enter these fields for a complete citation.`;
        warningEl.style.display = 'block';
    } else {
        warningEl.style.display = 'none';
    }

    return citation;
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
// OUTPUT: Generate and display citation
function generate() {
  // INPUT COLLECTION: Gather all user input from form fields
  // safe() is a helper function that trims whitespace and handles empty values
  const payload = {
    author: safe(authorEl.value),    // Get value from author input field
    date: safe(dateEl.value),        // Get value from date input field
    title: safe(titleEl.value),      // Get value from title input field
    source: safe(sourceEl.value),    // Get value from source input field
    url: safe(urlEl.value)           // Get value from URL input field
  };

  // VALIDATION: Track which required fields are missing
  const missing = [];  // Array to store names of missing fields
  
  // Define array of field objects for validation
  // Each object has: element reference, data key, and display label
  const fields = [
    { el: authorEl, key: 'author', label: 'Author' },
    { el: titleEl, key: 'title', label: 'Title' },
    { el: sourceEl, key: 'source', label: 'Source / Website' },
    { el: dateEl, key: 'date', label: 'Publication Date' }
  ];

  // ITERATION: Remove previous validation highlights from all fields
  // classList.remove() takes off the 'missing' CSS class
  fields.forEach(f => f.el.classList.remove('missing'));

  // ITERATION & SELECTION: Check each field for missing data
  fields.forEach(f => {
    // If the field value is empty (after being cleaned by safe())
    if (!payload[f.key]) {
      missing.push(f.label);              // Add to missing fields list
      f.el.classList.add('missing');      // Add red highlight CSS class
    }
  });

  // INPUT: Get selected citation style from dropdown
  const style = styleEl.value;  // Will be 'apa', 'mla', or 'chicago'
  
  // SELECTION: Choose appropriate formatting function based on style
  let citation = '';  // Variable to store formatted citation
  if (style === 'mla') citation = fmtMLA9(payload);           // MLA 9th edition
  else if (style === 'chicago') citation = fmtChicago(payload); // Chicago author-date
  else citation = fmtAPA(payload);                           // Default to APA

  // OUTPUT: Display the formatted citation to the user
  outTextEl.innerHTML = citation;  // Set HTML content of output div

  // Generate parenthetical citation (for in-text use)
  const parentheticalEl = document.getElementById('cite-parenthetical');
  // Spread operator {...payload, style} combines payload object with style
  const parenthetical = buildParenthetical({ ...payload, style });

  // OUTPUT: Display parenthetical citation if element exists
  if (parentheticalEl) {
    // Use ternary operator: condition ? trueValue : falseValue
    parentheticalEl.innerHTML = parenthetical
      ? `<span class="citation-output-label">Parenthetical Citation:</span>${parenthetical}`
      : '';  // Empty string if no parenthetical
  }

  // VALIDATION OUTPUT: Show warning message if fields are missing
  const warningEl = document.getElementById('cite-warning');
  if (missing.length > 0) {
    // Template literal with embedded variables and HTML
    warningEl.innerHTML =
      `‚ö†Ô∏è Missing citation info: <b>${missing.join(', ')}</b><br>
       Please manually enter these fields for a complete citation.`;
    warningEl.style.display = 'block';  // Make warning visible
  } else {
    warningEl.style.display = 'none';   // Hide warning if all fields present
  }

  // Return the generated citation (used when saving to works cited)
  return citation;
}
</code></pre>

</details>

---

### Code Segment 5: Output - Tactile Clipboard Interaction

**Purpose:** This code demonstrates tactile output by copying text to the user's clipboard, providing direct user interaction.

**Key Features:**
- **Output delivery:** Uses the modern Clipboard API to copy text
- **Fallback method:** Provides alternative copy method for browsers that don't support Clipboard API
- **User feedback:** Shows alert messages to confirm successful copy operation
- **Error handling:** Catches failures and attempts fallback method

```javascript
function copyToClipboard(text) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || '';

    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(plainText).then(() => {
            alert('‚úì Citation copied to clipboard!');
        }).catch(() => { 
            fallbackCopy(plainText);
        });
    } else {
        fallbackCopy(plainText);
    }
}

function fallbackCopy(text) {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.opacity = '0';
    document.body.appendChild(ta);
    ta.select();
    try { 
        document.execCommand('copy');
        alert('‚úì Citation copied to clipboard!');
    } catch (e) {
        alert('Copy failed. Please manually copy the citation.');
    }
    ta.remove();
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
// OUTPUT: Copy to clipboard (tactile/visual feedback)
function copyToClipboard(text) {
    // HTML PARSING: Strip HTML tags to get plain text
    // Create temporary div element to parse HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;  // Set HTML content
    
    // Extract plain text (without HTML tags)
    // textContent and innerText are browser-compatible ways to get text
    // || '' provides empty string fallback if both are undefined
    const plainText = tempDiv.textContent || tempDiv.innerText || '';

    // MODERN API: Try using the Clipboard API first (newer browsers)
    // navigator.clipboard is a modern web API for clipboard operations
    if (navigator.clipboard && navigator.clipboard.writeText) {
        // writeText() returns a Promise (asynchronous operation)
        navigator.clipboard.writeText(plainText)
            .then(() => {
                // SUCCESS: This code runs if copy succeeds
                alert('‚úì Citation copied to clipboard!');
            })
            .catch(() => { 
                // ERROR HANDLING: If Clipboard API fails, try fallback method
                fallbackCopy(plainText);
            });
    } else {
        // FALLBACK: If Clipboard API not supported, use fallback method
        fallbackCopy(plainText);
    }
}

// FALLBACK METHOD: Older approach for browsers without Clipboard API
function fallbackCopy(text) {
    // DOM MANIPULATION: Create temporary textarea element
    const ta = document.createElement('textarea');
    ta.value = text;  // Set the text to copy
    
    // Make textarea invisible but keep it in DOM
    ta.style.position = 'fixed';  // Position fixed so it doesn't affect layout
    ta.style.opacity = '0';       // Completely transparent
    
    // Add textarea to page (required for selection to work)
    document.body.appendChild(ta);
    
    // Select all text in the textarea
    ta.select();
    
    // ERROR HANDLING: Try to execute copy command
    try { 
        // execCommand is an older API that works in most browsers
        document.execCommand('copy');
        alert('‚úì Citation copied to clipboard!');
    } catch (e) {
        // If all copy methods fail, tell user to copy manually
        alert('Copy failed. Please manually copy the citation.');
    }
    
    // CLEANUP: Remove temporary textarea from page
    ta.remove();
}
</code></pre>

</details>

---

### Code Segment 6: Backend API - Citation Quality Check

**Purpose:** This backend procedure checks citation quality using multiple algorithms, demonstrating server-side processing with Python/Flask.

**Key Features:**
- **Parameters:** Takes `url`, `author`, `date`, `source`, and `fetch_page` as inputs
- **Return type:** Returns a dictionary with score and detailed analysis
- **Algorithm elements:** Uses sequencing (ordered checks), selection (conditional scoring), and iteration (processing through quality criteria)
- **Procedure calls:** Calls helper function `check_author_credentials` to evaluate author information

```python
def check_citation_quality_enhanced(url, author, date, source, fetch_page=False):
    score = 5
    reasons = []
    
    try:
        parsed = urlparse(url)
        domain = parsed.netloc.lower().replace('www.', '')
        
        if domain in CREDIBLE_DOMAINS:
            score = CREDIBLE_DOMAINS[domain]
            reasons.append(f"Known credible source ({CREDIBLE_DOMAINS[domain]}/10 base)")
        elif domain in QUESTIONABLE_DOMAINS:
            score = QUESTIONABLE_DOMAINS[domain]
            reasons.append(f"Known questionable source ({QUESTIONABLE_DOMAINS[domain]}/10 base)")
        else:
            reasons.append("Unknown domain (5/10 base)")
        
        if domain.endswith(('.edu', '.ac.uk', '.edu.au')):
            adj = +2
            score += adj
            reasons.append(f"Educational institution (+{adj})")
        elif domain.endswith(('.gov', '.gov.uk')):
            adj = +2
            score += adj
            reasons.append(f"Government source (+{adj})")
        
        if parsed.scheme == 'https':
            adj = +1
            score += adj
            reasons.append(f"Secure connection (+{adj})")
        
        author_adj = check_author_credentials(author, url)
        if author_adj != 0:
            score += author_adj
            if author_adj > 0:
                reasons.append(f"Author credentials (+{author_adj})")
            else:
                reasons.append(f"No author listed ({author_adj})")
        
        final_score = min(max(score, 1), 10)
        
        return {
            'score': final_score,
            'reasons': reasons,
            'raw_score': score
        }
        
    except Exception as e:
        print(f"Error in quality check: {e}")
        return {
            'score': 5,
            'reasons': ['Error during analysis'],
            'raw_score': 5
        }
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-python">
# BACKEND PROCEDURE: Check citation quality using multiple algorithms
def check_citation_quality_enhanced(url, author, date, source, fetch_page=False):
    """
    Purpose: Evaluate the quality/credibility of a citation source
    
    Parameters:
    - url (string): The web URL of the source
    - author (string): Author name(s)
    - date (string): Publication date
    - source (string): Publication/website name
    - fetch_page (boolean): Whether to fetch and analyze page content
    
    Returns: Dictionary with score, reasons, and raw_score
    
    Algorithm demonstrates:
    - SEQUENCING: Steps execute in specific order
    - SELECTION: Conditional logic based on domain type
    - ITERATION: Processing through quality criteria
    - PROCEDURE CALL: Calls check_author_credentials helper function
    """
    
    # SEQUENCING: Initialize score at baseline (5/10)
    score = 5
    reasons = []  # List to track why score changed
    
    # ERROR HANDLING: Wrap logic in try-except block
    try:
        # INPUT PROCESSING: Parse URL to extract domain
        parsed = urlparse(url)  # Built-in Python function
        
        # String manipulation: remove www. prefix and convert to lowercase
        domain = parsed.netloc.lower().replace('www.', '')
        
        # SELECTION: Check if domain is in known credible sources list
        # CREDIBLE_DOMAINS is a dictionary defined elsewhere
        if domain in CREDIBLE_DOMAINS:
            # Set score based on pre-defined credibility rating
            score = CREDIBLE_DOMAINS[domain]
            reasons.append(f"Known credible source ({CREDIBLE_DOMAINS[domain]}/10 base)")
        
        # SELECTION: Check if domain is in questionable sources list
        elif domain in QUESTIONABLE_DOMAINS:
            score = QUESTIONABLE_DOMAINS[domain]
            reasons.append(f"Known questionable source ({QUESTIONABLE_DOMAINS[domain]}/10 base)")
        
        # SELECTION: If domain not in either list, keep baseline
        else:
            reasons.append("Unknown domain (5/10 base)")
        
        # ALGORITHM: Check for educational institution domain
        # .endswith() checks if string ends with any of these suffixes
        if domain.endswith(('.edu', '.ac.uk', '.edu.au')):
            adj = +2  # Adjustment value
            score += adj  # Add to current score
            reasons.append(f"Educational institution (+{adj})")
        
        # SELECTION: Check for government domain
        elif domain.endswith(('.gov', '.gov.uk')):
            adj = +2
            score += adj
            reasons.append(f"Government source (+{adj})")
        
        # ALGORITHM: Check for secure HTTPS connection
        # parsed.scheme will be 'http' or 'https'
        if parsed.scheme == 'https':
            adj = +1
            score += adj
            reasons.append(f"Secure connection (+{adj})")
        
        # PROCEDURE CALL: Call helper function to check author
        # This demonstrates procedural abstraction - breaking complex logic into smaller functions
        author_adj = check_author_credentials(author, url)
        
        # SELECTION: Apply author adjustment if non-zero
        if author_adj != 0:
            score += author_adj  # Can be positive or negative
            
            # SELECTION: Different message for positive vs negative adjustment
            if author_adj > 0:
                reasons.append(f"Author credentials (+{author_adj})")
            else:
                reasons.append(f"No author listed ({author_adj})")
        
        # ALGORITHM: Clamp score between 1 and 10
        # min() and max() ensure score stays in valid range
        # max(score, 1) ensures score >= 1
        # min(..., 10) ensures score <= 10
        final_score = min(max(score, 1), 10)
        
        # RETURN: Package results in a dictionary
        # Dictionaries are like JavaScript objects - key:value pairs
        return {
            'score': final_score,      # Final adjusted score
            'reasons': reasons,         # List of explanations
            'raw_score': score          # Score before clamping
        }
        
    # ERROR HANDLING: Catch any exceptions that occur
    except Exception as e:
        # Log error for debugging
        print(f"Error in quality check: {e}")
        
        # RETURN: Safe default values if error occurs
        return {
            'score': 5,
            'reasons': ['Error during analysis'],
            'raw_score': 5
        }
</code></pre>

</details>

---

## COMPONENT C: PERSONALIZED PROJECT REFERENCE

### Section 1: PROCEDURE

#### i. Student-Developed Procedure Definition

This procedure filters and processes a list of citations. It demonstrates an algorithm with **sequencing** (ordered variable initialization), **selection** (conditional filtering with if-statements), and **iteration** (for-loop through the citation list). The procedure takes three parameters and returns a structured object with filtered results.

```javascript
function processCitationList(citationList, filterStyle, maxItems) {
    let filtered = [];
    let styleCount = { apa: 0, mla: 0, chicago: 0 };
    
    for (let i = 0; i < citationList.length; i++) {
        let citation = citationList[i];
        
        if (filterStyle === 'all' || citation.style === filterStyle) {
            filtered.push(citation);
        }
        
        if (citation.style && styleCount.hasOwnProperty(citation.style)) {
            styleCount[citation.style]++;
        }
        
        if (filtered.length >= maxItems) {
            break;
        }
    }
    
    return {
        citations: filtered,
        totalCount: citationList.length,
        styleCounts: styleCount
    };
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
/* 
 * COMPONENT C - PROCEDURE REQUIREMENT
 * 
 * This is the STUDENT-DEVELOPED PROCEDURE for AP CSP Performance Task
 * 
 * Name: processCitationList
 * 
 * Parameters (3 required):
 *   1. citationList (array/list) - Collection of citation objects to process
 *   2. filterStyle (string) - Style to filter by: "apa", "mla", "chicago", or "all"
 *   3. maxItems (number) - Maximum number of items to return
 * 
 * Return type: Object containing:
 *   - citations: Filtered array of citation objects
 *   - totalCount: Total number of citations before filtering
 *   - styleCounts: Object with counts for each citation style
 * 
 * Algorithm includes:
 *   - SEQUENCING: Steps execute in order (initialize, loop, return)
 *   - SELECTION: If-statements for conditional logic
 *   - ITERATION: For-loop processes each element
 */

function processCitationList(citationList, filterStyle, maxItems) {
    // SEQUENCING STEP 1: Initialize empty array for filtered results
    let filtered = [];
    
    // SEQUENCING STEP 2: Initialize object to count citations by style
    // This object acts as a counter for each citation style
    let styleCount = { 
        apa: 0,       // Counter for APA citations
        mla: 0,       // Counter for MLA citations
        chicago: 0    // Counter for Chicago citations
    };
    
    // ITERATION: Loop through each citation in the input list
    // Standard for-loop iterates from index 0 to length-1
    for (let i = 0; i < citationList.length; i++) {
        // Get the citation object at current index
        let citation = citationList[i];
        
        // SELECTION: Conditional logic to filter citations
        // Include citation if:
        //   - filterStyle is 'all' (include everything), OR
        //   - citation's style matches the filterStyle
        if (filterStyle === 'all' || citation.style === filterStyle) {
            filtered.push(citation);  // Add to filtered array
        }
        
        // SELECTION: Update style count if citation has a valid style
        // hasOwnProperty() checks if the style exists in our styleCount object
        // This prevents errors if citation has an unexpected style value
        if (citation.style && styleCount.hasOwnProperty(citation.style)) {
            styleCount[citation.style]++;  // Increment counter for this style
        }
        
        // SELECTION: Stop early if we've reached the maximum number of items
        // This is an optimization - no need to process more citations
        if (filtered.length >= maxItems) {
            break;  // Exit the loop immediately
        }
    }
    
    // SEQUENCING STEP 3: Return results as a structured object
    // This demonstrates data abstraction - packaging related data together
    return {
        citations: filtered,              // The filtered citation list
        totalCount: citationList.length,  // Original list size (before filtering)
        styleCounts: styleCount           // Statistics about citation styles
    };
}

/*
 * WHY THIS PROCEDURE MANAGES COMPLEXITY:
 * 
 * Without this procedure, the code would need to:
 * 1. Manually track filtered citations in multiple places
 * 2. Repeat filtering logic whenever citations need to be processed
 * 3. Separately count citations by style each time
 * 4. Handle edge cases (empty lists, max items) repeatedly
 * 
 * This procedure ABSTRACTS the complexity by:
 * - Encapsulating all filtering logic in one place
 * - Providing a reusable function for processing citations
 * - Handling edge cases consistently
 * - Making the code more maintainable and easier to test
 */
</code></pre>

</details>

#### ii. Procedure Call

This shows the `processCitationList` procedure being called with actual parameters: the saved citations array, the filter string `'all'`, and max items of `50`. The returned result object is then used to organize and display the citations by style.

```javascript
async function loadWorksCited() {
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    if (saved.length === 0) {
        worksCitedSection.style.display = 'none';
        return;
    }

    const result = processCitationList(saved, 'all', 50);
    
    worksCitedSection.style.display = 'block';
    worksCitedByStyle.innerHTML = '';

    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    result.citations.forEach((citation, index) => {
        if (byStyle[citation.style]) {
            byStyle[citation.style].push({ item: citation, index });
        }
    });
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
/*
 * COMPONENT C - PROCEDURE CALL REQUIREMENT
 * 
 * This code shows WHERE and HOW the student-developed procedure is called
 */

async function loadWorksCited() {
    // Retrieve saved citations from localStorage
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    // Early exit if no citations saved
    if (saved.length === 0) {
        worksCitedSection.style.display = 'none';
        return;
    }

    // === PROCEDURE CALL ===
    // Calling the student-developed procedure with actual arguments:
    //   Argument 1: saved (array of citation objects)
    //   Argument 2: 'all' (filter string - include all styles)
    //   Argument 3: 50 (maximum number of items to return)
    const result = processCitationList(saved, 'all', 50);
    
    // The result object now contains:
    //   result.citations - filtered array of citations
    //   result.totalCount - total count before filtering
    //   result.styleCounts - object with counts by style
    
    // Show the works cited section
    worksCitedSection.style.display = 'block';
    
    // Clear any existing content
    worksCitedByStyle.innerHTML = '';

    // Create object to organize citations by style
    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    // USING THE PROCEDURE'S RETURN VALUE:
    // Process the filtered citations from the procedure call
    result.citations.forEach((citation, index) => {
        // Group each citation by its style
        if (byStyle[citation.style]) {
            byStyle[citation.style].push({ item: citation, index });
        }
    });
    
    // ...rest of function continues to display the organized citations
}

/*
 * EXPLANATION OF PROCEDURE CALL:
 * 
 * 1. INPUT (Arguments):
 *    - saved: The complete list of saved citations
 *    - 'all': Filter parameter meaning "include all styles"
 *    - 50: Maximum number of citations to return
 * 
 * 2. PROCESSING (Inside procedure):
 *    The procedure filters, counts, and organizes the citations
 * 
 * 3. OUTPUT (Return value):
 *    Returns object with filtered citations and statistics
 * 
 * 4. USAGE (After call):
 *    The result is used to display citations organized by style
 */
</code></pre>

</details>

---

### Section 2: LIST

#### i. Storing Data in List

This code demonstrates **storing a citation object into a list** (array). The list is retrieved from localStorage as a JSON array, a new citation object is created with all necessary properties, and then added to the array using the `push()` method. The updated list is saved back to storage, demonstrating how the list manages multiple citation objects.

```javascript
function saveToWorksCited() {
    const citation = generate();
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };
    
    const style = styleEl.value;
    const parenthetical = buildParenthetical({ ...payload, style });
    
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    const newCitation = { 
        citation, 
        style: styleEl.value,
        at: Date.now(),
        source: safe(sourceEl.value),
        title: safe(titleEl.value),
        url: safe(urlEl.value),
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        parenthetical: parenthetical
    };
    
    saved.push(newCitation);
    localStorage.setItem(KEY, JSON.stringify(saved));
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
/*
 * COMPONENT C - LIST REQUIREMENT (Part i: Storing data in the list)
 * 
 * This code shows HOW DATA IS STORED in the list/collection
 */

function saveToWorksCited() {
    // Generate formatted citation first
    const citation = generate();
    
    // Gather form data into payload object
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };
    
    // Get citation style and build parenthetical
    const style = styleEl.value;
    const parenthetical = buildParenthetical({ ...payload, style });
    
    // === RETRIEVING THE LIST ===
    // Get existing list from localStorage
    // JSON.parse converts string back to JavaScript array
    // || '[]' provides empty array if nothing stored yet
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    // This is the LIST/COLLECTION that manages complexity
    // Instead of separate variables for each citation:
    //   citation1, citation2, citation3, etc.
    // We use ONE array to store ALL citations
    
    // === CREATING NEW LIST ELEMENT ===
    // Each element in the list is an object with multiple properties
    // This demonstrates DATA ABSTRACTION - complex data stored in organized structure
    const newCitation = { 
        citation,                      // The formatted citation text
        style: styleEl.value,          // Citation style (apa/mla/chicago)
        at: Date.now(),                // Timestamp when saved
        source: safe(sourceEl.value),  // Source name
        title: safe(titleEl.value),    // Article title
        url: safe(urlEl.value),        // Web URL
        author: safe(authorEl.value),  // Author name
        date: safe(dateEl.value),      // Publication date
        parenthetical: parenthetical   // Parenthetical citation
    };
    
    // === ADDING TO THE LIST ===
    // push() adds the new citation to the END of the array
    // This is the KEY ACTION that stores data in the list
    saved.push(newCitation);
    
    // === PERSISTING THE LIST ===
    // Save updated array back to localStorage
    // JSON.stringify converts array to string for storage
    localStorage.setItem(KEY, JSON.stringify(saved));
}

/*
 * HOW THE LIST MANAGES COMPLEXITY:
 * 
 * WITHOUT the list, we would need:
 * - Separate variables: citation1, citation2, citation3...
 * - Individual save operations for each citation
 * - Manual tracking of how many citations exist
 * - Complex code to add, remove, or update citations
 * 
 * WITH the list, we can:
 * - Store unlimited citations in ONE data structure
 * - Easily add new citations with a single .push()
 * - Iterate through all citations with a simple loop
 * - Filter, sort, and organize citations efficiently
 * - Pass the entire collection to functions
 * 
 * The list ABSTRACTS the complexity of managing multiple related items,
 * making the program simpler and more maintainable.
 */
</code></pre>

</details>

#### ii. Using Data from List

This code demonstrates **accessing and processing data from the list**. It retrieves the saved citations array, then uses `forEach` to iterate through each item. The citations are grouped by style (apa, mla, chicago), and then each group is processed to create display elements. This shows how the list abstraction allows efficient organization and display of multiple citations.

```javascript
async function loadWorksCited() {
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');

    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    saved.forEach((item, index) => {
        if (byStyle[item.style]) {
            byStyle[item.style].push({ item, index });
        }
    });

    ['apa', 'mla', 'chicago'].forEach(style => {
        if (byStyle[style].length > 0) {
            byStyle[style].forEach(async ({ item, index }) => {
                const citationDiv = document.createElement('div');
                citationDiv.className = 'citation-item';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'citation-text';
                textDiv.innerHTML = item.citation;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.onclick = () => deleteCitation(index);
            });
        }
    });
}
```

<details>
<summary><strong>üìö Click to view commented study guide version</strong></summary>

<pre><code class="language-javascript">
/*
 * COMPONENT C - LIST REQUIREMENT (Part ii: Using data from the list)
 * 
 * This code shows HOW THE LIST IS ACCESSED AND USED in the program
 */

async function loadWorksCited() {
    // === RETRIEVING THE LIST ===
    // Get the list from localStorage
    // This is the SAME list where we stored citations earlier
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    // Now 'saved' is an ARRAY of citation objects
    // Each object has properties: citation, style, author, title, etc.
    
    // Create object to organize citations by style
    const byStyle = {
        apa: [],       // Will hold APA citations
        mla: [],       // Will hold MLA citations
        chicago: []    // Will hold Chicago citations
    };

    // === ACCESSING LIST ELEMENTS ===
    // forEach is an array method that processes each element
    // For each citation in the list:
    //   item = the citation object
    //   index = its position in the array (0, 1, 2, etc.)
    saved.forEach((item, index) => {
        // Access the 'style' property of each citation object
        // This shows how we ACCESS DATA from individual list elements
        if (byStyle[item.style]) {
            // Group citations by style
            // We're using the data from the list to organize it differently
            byStyle[item.style].push({ item, index });
        }
    });

    // === PROCESSING LIST DATA ===
    // Iterate through each style category
    ['apa', 'mla', 'chicago'].forEach(style => {
        // Check if there are any citations in this style
        if (byStyle[style].length > 0) {
            
            // Process each citation in this style
            // This is NESTED ITERATION - looping within a loop
            byStyle[style].forEach(async ({ item, index }) => {
                // Create display elements for this citation
                const citationDiv = document.createElement('div');
                citationDiv.className = 'citation-item';
                
                // Access citation TEXT from the list element
                const textDiv = document.createElement('div');
                textDiv.className = 'citation-text';
                textDiv.innerHTML = item.citation;  // Using data from list
                
                // Create delete button that uses the citation's index
                const deleteBtn = document.createElement('button');
                // The index lets us identify which list element to delete
                deleteBtn.onclick = () => deleteCitation(index);
                
                // ...rest of display code
            });
        }
    });
}

/*
 * HOW THE LIST IS USED:
 * 
 * 1. RETRIEVAL: Get the entire list from storage
 *    - All citations are loaded at once
 *    - No need to load each citation individually
 * 
 * 2. ITERATION: Process each element in the list
 *    - forEach loop automatically handles all elements
 *    - Works regardless of how many citations exist (0, 1, 10, 100...)
 * 
 * 3. DATA ACCESS: Extract properties from each citation
 *    - item.citation: Get the formatted citation text
 *    - item.style: Get the citation style
 *    - item.author: Get the author name
 *    - And so on for all properties
 * 
 * 4. ORGANIZATION: Group and sort the data
 *    - Separate citations by style (APA, MLA, Chicago)
 *    - Could also sort by date, author, etc.
 * 
 * 5. DISPLAY: Show the data to the user
 *    - Create HTML elements for each citation
 *    - Add buttons that reference specific list elements
 * 
 * WHY THE LIST SIMPLIFIES THE PROGRAM:
 * 
 * Without the list, we would need:
 * - Separate code to load each individual citation
 * - Complex logic to determine how many citations exist
 * - Manual tracking of which citations go in which category
 * - Difficult-to-maintain code with many variables
 * 
 * With the list, we can:
 * - Load all citations with one operation
 * - Automatically process any number of citations
 * - Use loops to organize and display data
 * - Add, remove, or modify citations easily
 * 
 * The list ABSTRACTS the complexity of managing multiple related data items,
 * making the program more elegant and easier to maintain.
 */
```

</details>

---