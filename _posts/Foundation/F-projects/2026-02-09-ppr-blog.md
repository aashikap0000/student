---
layout: post
title: Personal Project Reference- Citation Generator
permalink: /ppr
comments: true
---
Personal Project Reference (PPR)
AP Computer Science Principles - Media Literacy Citation Generator

COMPONENT A: PROGRAM CODE
Project Overview
This citation generator helps students create properly formatted academic citations in APA, MLA, and Chicago styles while managing a collection of saved references. The program demonstrates data abstraction through list processing and includes algorithms for filtering, sorting, and quality-checking citations.

Code Segment 1: Student-Developed Procedure with Algorithm
Purpose: This procedure processes and filters a collection of citations based on style and maximum items, demonstrating sequencing, selection, and iteration.
javascript/**
 * STUDENT-DEVELOPED PROCEDURE: processCitationList
 * Purpose: Process and filter a list of saved citations based on style and date range
 * 
 * Parameters:
 *   - citationList (array): List of citation objects to process
 *   - filterStyle (string): Citation style to filter by (e.g., "apa", "mla", "chicago", or "all")
 *   - maxItems (number): Maximum number of items to return
 * 
 * Return type: Object containing filtered citations and statistics
 * 
 * This procedure demonstrates:
 * - LISTS/COLLECTION: Works with array of citation objects
 * - ITERATION: Loops through citation list
 * - SEQUENCING: Steps execute in specific order
 * - SELECTION: Conditional logic for filtering
 * - ALGORITHM: Complete process for filtering and counting
 * - ABSTRACTION: Encapsulates complex filtering logic
 */
function processCitationList(citationList, filterStyle, maxItems) {
    // SEQUENCING: Initialize variables in order
    let filtered = [];
    let styleCount = { apa: 0, mla: 0, chicago: 0 };
    
    // ITERATION: Loop through each citation in the list
    for (let i = 0; i < citationList.length; i++) {
        let citation = citationList[i];
        
        // SELECTION: Conditional logic to filter by style
        if (filterStyle === 'all' || citation.style === filterStyle) {
            filtered.push(citation);
        }
        
        // Count citations by style
        if (citation.style && styleCount.hasOwnProperty(citation.style)) {
            styleCount[citation.style]++;
        }
        
        // SELECTION: Stop if we've reached max items
        if (filtered.length >= maxItems) {
            break;
        }
    }
    
    // Return processed data
    return {
        citations: filtered,
        totalCount: citationList.length,
        styleCounts: styleCount
    };
}

Code Segment 2: List Data Structure - Storing Citations
Purpose: This code shows how citation data is stored in a list (array) structure in localStorage, demonstrating data abstraction.
javascriptfunction saveToWorksCited() {
    const citation = generate();
    if (!citation || citation.length < 5) {
        alert('Please generate a citation first.');
        return;
    }
    
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };
    
    const style = styleEl.value;
    const parenthetical = buildParenthetical({ ...payload, style });
    
    // INPUT: Get existing list from storage
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    // Create new citation object
    const newCitation = { 
        citation, 
        style: styleEl.value,
        at: Date.now(),
        source: safe(sourceEl.value),
        title: safe(titleEl.value),
        url: safe(urlEl.value),
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        parenthetical: parenthetical
    };
    
    // Add to list - MANAGING COMPLEXITY through collection
    saved.push(newCitation);
    
    // OUTPUT: Save updated list back to storage
    localStorage.setItem(KEY, JSON.stringify(saved));
    alert('✓ Citation saved to References!');
    
    loadWorksCited();
    updateNotesSourceSelect();
}

Code Segment 3: Using List Data - Processing and Display
Purpose: This code retrieves the citation list and processes it to display organized references by style, showing how the list abstraction manages program complexity.
javascriptasync function loadWorksCited() {
    // INPUT: Get list from storage
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    if (saved.length === 0) {
        worksCitedSection.style.display = 'none';
        return;
    }

    // OUTPUT: Display results
    worksCitedSection.style.display = 'block';
    worksCitedByStyle.innerHTML = '';

    // MANAGING COMPLEXITY: Group citations by style using object
    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    // ITERATION: Process each citation in the list
    saved.forEach((item, index) => {
        if (byStyle[item.style]) {
            byStyle[item.style].push({ item, index });
        }
    });

    // ITERATION: Display each style group
    const styleLabels = {
        apa: 'APA',
        mla: 'MLA (9th ed.)',
        chicago: 'Chicago (author-date)'
    };

    ['apa', 'mla', 'chicago'].forEach(style => {
        if (byStyle[style].length > 0) {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'style-group';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'style-group-header';
            headerDiv.textContent = `${styleLabels[style]} (${byStyle[style].length})`;
            groupDiv.appendChild(headerDiv);

            const listDiv = document.createElement('div');
            listDiv.className = 'works-cited-list';

            // ITERATION: Create display elements for each citation
            byStyle[style].forEach(async ({ item, index }) => {
                const citationDiv = document.createElement('div');
                citationDiv.className = 'citation-item';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'citation-text';
                textDiv.innerHTML = item.citation;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'citation-actions';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'citation-delete';
                deleteBtn.innerHTML = '×';
                deleteBtn.title = 'Delete this citation';
                deleteBtn.onclick = () => deleteCitation(index);
                
                actionsDiv.appendChild(deleteBtn);
                citationDiv.appendChild(textDiv);
                citationDiv.appendChild(actionsDiv);
                listDiv.appendChild(citationDiv);
            });

            groupDiv.appendChild(listDiv);
            worksCitedByStyle.appendChild(groupDiv);
        }
    });
}

Code Segment 4: Input Processing - User Form Data
Purpose: This code demonstrates input collection from user interface elements (form fields).
javascriptfunction generate() {
    // INPUT: Collect data from user input fields
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };

    const missing = [];
    const fields = [
        { el: authorEl, key: 'author', label: 'Author' },
        { el: titleEl, key: 'title', label: 'Title' },
        { el: sourceEl, key: 'source', label: 'Source / Website' },
        { el: dateEl, key: 'date', label: 'Publication Date' }
    ];

    // SEQUENCING and SELECTION: Reset highlights and detect missing fields
    fields.forEach(f => f.el.classList.remove('missing'));

    fields.forEach(f => {
        if (!payload[f.key]) {
            missing.push(f.label);
            f.el.classList.add('missing');
        }
    });

    // SELECTION: Choose formatting function based on style
    const style = styleEl.value;
    let citation = '';
    if (style === 'mla') citation = fmtMLA9(payload);
    else if (style === 'chicago') citation = fmtChicago(payload);
    else citation = fmtAPA(payload);

    // OUTPUT: Display formatted citation
    outTextEl.innerHTML = citation;

    const parentheticalEl = document.getElementById('cite-parenthetical');
    const parenthetical = buildParenthetical({ ...payload, style });

    if (parentheticalEl) {
        parentheticalEl.innerHTML = parenthetical
            ? `<span class="citation-output-label">Parenthetical Citation:</span>${parenthetical}`
            : '';
    }

    // OUTPUT: Visual feedback for missing fields
    const warningEl = document.getElementById('cite-warning');
    if (missing.length > 0) {
        warningEl.innerHTML =
            `⚠️ Missing citation info: <b>${missing.join(', ')}</b><br>
             Please manually enter these fields for a complete citation.`;
        warningEl.style.display = 'block';
    } else {
        warningEl.style.display = 'none';
    }

    return citation;
}

Code Segment 5: Output - Tactile Clipboard Interaction
Purpose: This code demonstrates tactile output by copying text to the user's clipboard.
javascriptfunction copyToClipboard(text) {
    // Create temporary element to extract plain text from HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || '';

    // OUTPUT: Modern clipboard API (preferred method)
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(plainText).then(() => {
            // OUTPUT: Visual feedback
            alert('✓ Citation copied to clipboard!');
        }).catch(() => { 
            fallbackCopy(plainText);
        });
    } else {
        fallbackCopy(plainText);
    }
}

function fallbackCopy(text) {
    // OUTPUT: Fallback tactile output method
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.opacity = '0';
    document.body.appendChild(ta);
    ta.select();
    try { 
        document.execCommand('copy');
        alert('✓ Citation copied to clipboard!');
    } catch (e) {
        alert('Copy failed. Please manually copy the citation.');
    }
    ta.remove();
}

Code Segment 6: Backend API - Citation Quality Check (Flask)
Purpose: This backend procedure checks citation quality using multiple algorithms, demonstrating server-side processing.
pythondef check_citation_quality_enhanced(url, author, date, source, fetch_page=False):
    """
    Enhanced quality checking with multiple factors.
    Returns score from 1-10 with detailed reasoning.
    
    Parameters:
    - url (string): Citation URL to check
    - author (string): Author name
    - date (string): Publication date
    - source (string): Source name
    - fetch_page (boolean): Whether to fetch actual page content
    
    Return type: Dictionary with score and analysis
    """
    score = 5
    reasons = []
    
    try:
        # SEQUENCING: Parse URL first
        parsed = urlparse(url)
        domain = parsed.netloc.lower().replace('www.', '')
        
        # SELECTION: Check domain reputation
        if domain in CREDIBLE_DOMAINS:
            score = CREDIBLE_DOMAINS[domain]
            reasons.append(f"Known credible source ({CREDIBLE_DOMAINS[domain]}/10 base)")
        elif domain in QUESTIONABLE_DOMAINS:
            score = QUESTIONABLE_DOMAINS[domain]
            reasons.append(f"Known questionable source ({QUESTIONABLE_DOMAINS[domain]}/10 base)")
        else:
            reasons.append("Unknown domain (5/10 base)")
        
        # SELECTION: TLD bonuses
        if domain.endswith(('.edu', '.ac.uk', '.edu.au')):
            adj = +2
            score += adj
            reasons.append(f"Educational institution (+{adj})")
        elif domain.endswith(('.gov', '.gov.uk')):
            adj = +2
            score += adj
            reasons.append(f"Government source (+{adj})")
        
        # SELECTION: HTTPS check
        if parsed.scheme == 'https':
            adj = +1
            score += adj
            reasons.append(f"Secure connection (+{adj})")
        
        # PROCEDURE CALL: Check author credentials
        author_adj = check_author_credentials(author, url)
        if author_adj != 0:
            score += author_adj
            if author_adj > 0:
                reasons.append(f"Author credentials (+{author_adj})")
            else:
                reasons.append(f"No author listed ({author_adj})")
        
        # SELECTION and ITERATION: Cap between 1-10
        final_score = min(max(score, 1), 10)
        
        return {
            'score': final_score,
            'reasons': reasons,
            'raw_score': score
        }
        
    except Exception as e:
        print(f"Error in quality check: {e}")
        return {
            'score': 5,
            'reasons': ['Error during analysis'],
            'raw_score': 5
        }

COMPONENT C: PERSONALIZED PROJECT REFERENCE
Section 1: PROCEDURE
i. Student-Developed Procedure Definition
javascriptfunction processCitationList(citationList, filterStyle, maxItems) {
    let filtered = [];
    let styleCount = { apa: 0, mla: 0, chicago: 0 };
    
    for (let i = 0; i < citationList.length; i++) {
        let citation = citationList[i];
        
        if (filterStyle === 'all' || citation.style === filterStyle) {
            filtered.push(citation);
        }
        
        if (citation.style && styleCount.hasOwnProperty(citation.style)) {
            styleCount[citation.style]++;
        }
        
        if (filtered.length >= maxItems) {
            break;
        }
    }
    
    return {
        citations: filtered,
        totalCount: citationList.length,
        styleCounts: styleCount
    };
}
ii. Procedure Call
javascriptasync function loadWorksCited() {
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    if (saved.length === 0) {
        worksCitedSection.style.display = 'none';
        return;
    }

    const result = processCitationList(saved, 'all', 50);
    
    worksCitedSection.style.display = 'block';
    worksCitedByStyle.innerHTML = '';

    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    result.citations.forEach((citation, index) => {
        if (byStyle[citation.style]) {
            byStyle[citation.style].push({ item: citation, index });
        }
    });
}

Section 2: LIST
i. Storing Data in List
javascriptfunction saveToWorksCited() {
    const citation = generate();
    const payload = {
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        title: safe(titleEl.value),
        source: safe(sourceEl.value),
        url: safe(urlEl.value)
    };
    
    const style = styleEl.value;
    const parenthetical = buildParenthetical({ ...payload, style });
    
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');
    
    const newCitation = { 
        citation, 
        style: styleEl.value,
        at: Date.now(),
        source: safe(sourceEl.value),
        title: safe(titleEl.value),
        url: safe(urlEl.value),
        author: safe(authorEl.value),
        date: safe(dateEl.value),
        parenthetical: parenthetical
    };
    
    saved.push(newCitation);
    localStorage.setItem(KEY, JSON.stringify(saved));
}
ii. Using Data from List
javascriptasync function loadWorksCited() {
    const saved = JSON.parse(localStorage.getItem(KEY) || '[]');

    const byStyle = {
        apa: [],
        mla: [],
        chicago: []
    };

    saved.forEach((item, index) => {
        if (byStyle[item.style]) {
            byStyle[item.style].push({ item, index });
        }
    });

    ['apa', 'mla', 'chicago'].forEach(style => {
        if (byStyle[style].length > 0) {
            byStyle[style].forEach(async ({ item, index }) => {
                const citationDiv = document.createElement('div');
                citationDiv.className = 'citation-item';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'citation-text';
                textDiv.innerHTML = item.citation;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.onclick = () => deleteCitation(index);
            });
        }
    });
}